<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wolfenstein 3D - Three.js</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        canvas { display: block; }
        #hud {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 80px;
            background: linear-gradient(to bottom, #1a1a4a, #0a0a2a);
            border-top: 3px solid #888;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 40px;
            z-index: 10;
            image-rendering: pixelated;
        }
        .hud-item {
            text-align: center;
            color: #fff;
            text-shadow: 2px 2px #000;
        }
        .hud-label { font-size: 12px; color: #aaa; margin-bottom: 4px; }
        .hud-value { font-size: 28px; font-weight: bold; }
        .hud-value.health { color: #ff4444; }
        .hud-value.ammo { color: #ffcc00; }
        .hud-value.score { color: #44ff44; }
        .hud-value.level { color: #4488ff; }
        #weapon {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 5;
            image-rendering: pixelated;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
            z-index: 5;
            pointer-events: none;
            text-shadow: 1px 1px 2px #000;
        }
        #instructions {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            color: #fff;
            font-family: 'Courier New', monospace;
        }
        #instructions h1 {
            font-size: 48px;
            color: #cc0000;
            text-shadow: 3px 3px #000;
            margin-bottom: 10px;
            letter-spacing: 4px;
        }
        #instructions h2 {
            font-size: 18px;
            color: #888;
            margin-bottom: 40px;
        }
        #instructions .controls {
            text-align: left;
            font-size: 16px;
            line-height: 2;
            color: #ccc;
        }
        #instructions .controls span { color: #ffcc00; }
        #instructions .start-msg {
            margin-top: 40px;
            font-size: 20px;
            color: #ff4444;
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        #minimap {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 10;
            border: 2px solid #444;
            opacity: 0.8;
        }
        #damage-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 6;
            background: radial-gradient(ellipse at center, transparent 50%, rgba(139,0,0,0.4) 100%);
            opacity: 0;
            transition: opacity 0.1s;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h1>WOLFENSTEIN 3D</h1>
        <h2>Three.js Edition</h2>
        <div class="controls">
            <span>W A S D</span> — Move<br>
            <span>Mouse</span> — Look around<br>
            <span>Left Click</span> — Shoot<br>
            <span>E</span> — Open doors<br>
            <span>M</span> — Toggle minimap<br>
            <span>Shift</span> — Run<br>
        </div>
        <div class="start-msg">[ Click to Start ]</div>
    </div>
    <div id="crosshair">+</div>
    <div id="damage-overlay"></div>
    <canvas id="minimap" width="200" height="200"></canvas>
    <div id="hud">
        <div class="hud-item">
            <div class="hud-label">FLOOR</div>
            <div class="hud-value level" id="hud-level">1</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">SCORE</div>
            <div class="hud-value score" id="hud-score">0</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">HEALTH</div>
            <div class="hud-value health" id="hud-health">100%</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">AMMO</div>
            <div class="hud-value ammo" id="hud-ammo">50</div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // ─── Game State ────────────────────────────────
        const state = {
            health: 100,
            ammo: 50,
            score: 0,
            level: 1,
            shooting: false,
            shootCooldown: 0,
            minimapVisible: true,
            doors: [],
            enemies: [],
            pickups: [],
            moveSpeed: 4.0,
            runMultiplier: 1.8,
            mouseSensitivity: 0.002,
        };

        // ─── Level Map ─────────────────────────────────
        // 0=empty, 1=stone wall, 2=brick wall, 3=blue wall, 4=wood wall
        // 5=door, 6=enemy spawn, 7=health pickup, 8=ammo pickup, 9=treasure
        const MAP_W = 24;
        const MAP_H = 24;
        const CELL = 2; // each cell is 2x2 units
        // prettier-ignore
        const levelMap = [
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
            1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
            1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
            1,0,0,2,2,2,2,2,5,2,2,2,0,0,0,3,3,3,3,3,3,0,0,1,
            1,0,0,2,0,0,0,0,0,0,0,2,0,0,0,3,0,0,0,0,3,0,0,1,
            1,0,0,2,0,7,0,0,0,6,0,2,0,0,0,3,0,9,0,0,3,0,0,1,
            1,0,0,2,0,0,0,0,0,0,0,2,0,0,0,3,0,0,0,0,3,0,0,1,
            1,0,0,2,0,0,0,8,0,0,0,2,0,0,0,3,0,0,0,6,3,0,0,1,
            1,0,0,2,0,0,0,0,0,0,0,2,0,0,0,3,0,0,0,0,3,0,0,1,
            1,0,0,2,2,2,2,5,2,2,2,2,0,0,0,3,3,5,3,3,3,0,0,1,
            1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
            1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
            1,1,1,1,1,5,1,1,1,1,1,1,1,1,1,1,1,1,5,1,1,1,1,1,
            1,0,0,0,0,0,0,0,0,4,4,4,4,4,4,0,0,0,0,0,0,0,0,1,
            1,0,0,0,0,0,0,0,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,1,
            1,0,6,0,0,8,0,0,0,4,0,9,0,0,4,0,0,0,7,0,6,0,0,1,
            1,0,0,0,0,0,0,0,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,1,
            1,0,0,0,0,0,0,0,0,4,0,0,6,0,4,0,0,0,0,0,0,0,0,1,
            1,0,0,4,4,4,5,4,4,4,0,0,0,0,4,4,4,5,4,4,4,0,0,1,
            1,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,1,
            1,0,0,4,0,7,0,0,6,0,0,8,0,0,0,0,9,0,0,0,4,0,0,1,
            1,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,1,
            1,0,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,1,
            1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        ];

        function getCell(x, z) {
            if (x < 0 || x >= MAP_W || z < 0 || z >= MAP_H) return 1;
            return levelMap[z * MAP_W + x];
        }
        function setCell(x, z, v) {
            if (x >= 0 && x < MAP_W && z >= 0 && z < MAP_H)
                levelMap[z * MAP_W + x] = v;
        }

        // ─── Texture Generation (procedural) ──────────
        function createTexture(draw, size = 64) {
            const c = document.createElement('canvas');
            c.width = c.height = size;
            const ctx = c.getContext('2d');
            draw(ctx, size);
            const tex = new THREE.CanvasTexture(c);
            tex.magFilter = THREE.NearestFilter;
            tex.minFilter = THREE.NearestFilter;
            return tex;
        }

        function stoneTexture() {
            return createTexture((ctx, s) => {
                ctx.fillStyle = '#6b6b6b';
                ctx.fillRect(0, 0, s, s);
                for (let i = 0; i < 200; i++) {
                    ctx.fillStyle = `rgba(${50+Math.random()*60},${50+Math.random()*60},${50+Math.random()*60},0.5)`;
                    ctx.fillRect(Math.random()*s, Math.random()*s, 2+Math.random()*3, 2+Math.random()*3);
                }
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 1;
                for (let y = 0; y < s; y += 16) {
                    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(s, y); ctx.stroke();
                    const off = (y / 16) % 2 === 0 ? 0 : 16;
                    for (let x = off; x < s; x += 32) {
                        ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y+16); ctx.stroke();
                    }
                }
            });
        }

        function brickTexture() {
            return createTexture((ctx, s) => {
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(0, 0, s, s);
                for (let y = 0; y < s; y += 8) {
                    const off = (y / 8) % 2 === 0 ? 0 : 8;
                    for (let x = off; x < s; x += 16) {
                        const r = 120 + Math.random() * 40;
                        const g = 40 + Math.random() * 30;
                        const b = 10 + Math.random() * 20;
                        ctx.fillStyle = `rgb(${r},${g},${b})`;
                        ctx.fillRect(x+1, y+1, 14, 6);
                    }
                }
            });
        }

        function blueTexture() {
            return createTexture((ctx, s) => {
                ctx.fillStyle = '#1a1a6b';
                ctx.fillRect(0, 0, s, s);
                for (let i = 0; i < 150; i++) {
                    ctx.fillStyle = `rgba(${20+Math.random()*40},${20+Math.random()*40},${80+Math.random()*60},0.4)`;
                    ctx.fillRect(Math.random()*s, Math.random()*s, 2+Math.random()*4, 2+Math.random()*4);
                }
                // Eagle emblem
                ctx.fillStyle = '#3a3a9b';
                ctx.fillRect(20, 10, 24, 24);
                ctx.fillStyle = '#5555bb';
                ctx.fillRect(24, 14, 16, 16);
                ctx.strokeStyle = '#7777dd';
                ctx.lineWidth = 1;
                ctx.strokeRect(20, 10, 24, 24);
                // Banner stripe
                ctx.fillStyle = '#cc0000';
                ctx.fillRect(4, 44, 56, 8);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(4, 52, 56, 4);
            });
        }

        function woodTexture() {
            return createTexture((ctx, s) => {
                ctx.fillStyle = '#654321';
                ctx.fillRect(0, 0, s, s);
                for (let y = 0; y < s; y++) {
                    const brightness = Math.sin(y * 0.5) * 10 + Math.random() * 15;
                    ctx.fillStyle = `rgba(${100+brightness},${60+brightness},${20+brightness},0.3)`;
                    ctx.fillRect(0, y, s, 1);
                }
                for (let i = 0; i < 5; i++) {
                    const x = Math.random() * s;
                    ctx.strokeStyle = 'rgba(80,40,10,0.3)';
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.bezierCurveTo(x+5, s*0.3, x-5, s*0.6, x+3, s);
                    ctx.stroke();
                }
            });
        }

        function doorTexture() {
            return createTexture((ctx, s) => {
                ctx.fillStyle = '#5a5a5a';
                ctx.fillRect(0, 0, s, s);
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(2, 2, s/2-3, s-4);
                ctx.fillRect(s/2+1, 2, s/2-3, s-4);
                ctx.fillStyle = '#777';
                ctx.fillRect(0, 0, s, 3);
                ctx.fillRect(0, s-3, s, 3);
                ctx.fillRect(s/2-1, 0, 2, s);
                // Door handle
                ctx.fillStyle = '#cc9900';
                ctx.beginPath();
                ctx.arc(s*0.7, s*0.5, 3, 0, Math.PI*2);
                ctx.fill();
            });
        }

        function floorTexture() {
            return createTexture((ctx, s) => {
                ctx.fillStyle = '#444';
                ctx.fillRect(0, 0, s, s);
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 1;
                for (let x = 0; x < s; x += 16) {
                    for (let y = 0; y < s; y += 16) {
                        ctx.fillStyle = `rgb(${55+Math.random()*20},${55+Math.random()*20},${55+Math.random()*20})`;
                        ctx.fillRect(x, y, 16, 16);
                        ctx.strokeRect(x, y, 16, 16);
                    }
                }
            });
        }

        function ceilingTexture() {
            return createTexture((ctx, s) => {
                ctx.fillStyle = '#383838';
                ctx.fillRect(0, 0, s, s);
                for (let i = 0; i < 100; i++) {
                    const v = 40 + Math.random() * 30;
                    ctx.fillStyle = `rgb(${v},${v},${v})`;
                    ctx.fillRect(Math.random()*s, Math.random()*s, 2, 2);
                }
            });
        }

        // ─── Scene Setup ───────────────────────────────
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        scene.fog = new THREE.Fog(0x000000, 1, 20);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / (window.innerHeight - 80), 0.1, 100);
        camera.position.set(2 * CELL + CELL/2, 0.9, 2 * CELL + CELL/2); // start in open area
        camera.rotation.order = 'YXZ';

        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight - 80);
        renderer.setPixelRatio(1); // pixelated look
        renderer.shadowMap.enabled = true;
        document.body.prepend(renderer.domElement);

        // ─── Lighting ──────────────────────────────────
        const ambient = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambient);

        const playerLight = new THREE.PointLight(0xffeedd, 1.2, 12);
        playerLight.position.copy(camera.position);
        scene.add(playerLight);

        // Ceiling lights in rooms
        const lightPositions = [
            [6, 6], [16, 6], // top rooms
            [4, 16], [11, 16], [18, 16], // bottom rooms
        ];
        lightPositions.forEach(([x, z]) => {
            const light = new THREE.PointLight(0xffcc77, 0.8, 8);
            light.position.set(x * CELL, 1.8, z * CELL);
            scene.add(light);
            // Light fixture
            const fixtureGeo = new THREE.CylinderGeometry(0.1, 0.2, 0.1, 8);
            const fixtureMat = new THREE.MeshBasicMaterial({ color: 0xffcc77 });
            const fixture = new THREE.Mesh(fixtureGeo, fixtureMat);
            fixture.position.copy(light.position);
            scene.add(fixture);
        });

        // ─── Build Level Geometry ──────────────────────
        const textures = {
            1: stoneTexture(),
            2: brickTexture(),
            3: blueTexture(),
            4: woodTexture(),
        };

        const wallMaterials = {};
        for (const [k, tex] of Object.entries(textures)) {
            wallMaterials[k] = new THREE.MeshLambertMaterial({ map: tex });
        }

        const doorMat = new THREE.MeshLambertMaterial({ map: doorTexture() });
        const floorMat = new THREE.MeshLambertMaterial({ map: floorTexture() });
        const ceilMat = new THREE.MeshLambertMaterial({ map: ceilingTexture() });

        floorMat.map.wrapS = floorMat.map.wrapT = THREE.RepeatWrapping;
        floorMat.map.repeat.set(MAP_W, MAP_H);
        ceilMat.map.wrapS = ceilMat.map.wrapT = THREE.RepeatWrapping;
        ceilMat.map.repeat.set(MAP_W, MAP_H);

        // Floor
        const floorGeo = new THREE.PlaneGeometry(MAP_W * CELL, MAP_H * CELL);
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(MAP_W * CELL / 2, 0, MAP_H * CELL / 2);
        scene.add(floor);

        // Ceiling
        const ceilGeo = new THREE.PlaneGeometry(MAP_W * CELL, MAP_H * CELL);
        const ceiling = new THREE.Mesh(ceilGeo, ceilMat);
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.set(MAP_W * CELL / 2, CELL, MAP_H * CELL / 2);
        scene.add(ceiling);

        // Walls and doors
        const wallGeo = new THREE.BoxGeometry(CELL, CELL, CELL);
        const wallColliders = [];

        for (let z = 0; z < MAP_H; z++) {
            for (let x = 0; x < MAP_W; x++) {
                const cell = getCell(x, z);
                const wx = x * CELL + CELL / 2;
                const wz = z * CELL + CELL / 2;

                if (cell >= 1 && cell <= 4) {
                    const wall = new THREE.Mesh(wallGeo, wallMaterials[cell]);
                    wall.position.set(wx, CELL / 2, wz);
                    scene.add(wall);
                    wallColliders.push({ x, z, mesh: wall, type: 'wall' });
                } else if (cell === 5) {
                    // Door
                    const door = new THREE.Mesh(wallGeo, doorMat);
                    door.position.set(wx, CELL / 2, wz);
                    door.userData = { open: false, opening: false, openAmount: 0, gridX: x, gridZ: z };
                    scene.add(door);
                    state.doors.push(door);
                    wallColliders.push({ x, z, mesh: door, type: 'door' });
                } else if (cell === 6) {
                    spawnEnemy(wx, wz);
                } else if (cell === 7) {
                    spawnPickup(wx, wz, 'health');
                } else if (cell === 8) {
                    spawnPickup(wx, wz, 'ammo');
                } else if (cell === 9) {
                    spawnPickup(wx, wz, 'treasure');
                }
            }
        }

        // ─── Enemies ───────────────────────────────────
        function createEnemyTexture() {
            return createTexture((ctx, s) => {
                // Body (gray uniform)
                ctx.fillStyle = '#556655';
                ctx.fillRect(16, 20, 32, 30);
                // Head
                ctx.fillStyle = '#dda87a';
                ctx.fillRect(22, 4, 20, 18);
                // Eyes
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(26, 10, 4, 4);
                ctx.fillRect(34, 10, 4, 4);
                // Helmet
                ctx.fillStyle = '#444';
                ctx.fillRect(20, 2, 24, 10);
                // Gun
                ctx.fillStyle = '#333';
                ctx.fillRect(10, 28, 8, 4);
                ctx.fillRect(6, 26, 6, 2);
                // Legs
                ctx.fillStyle = '#333';
                ctx.fillRect(20, 50, 10, 14);
                ctx.fillRect(34, 50, 10, 14);
                // Boots
                ctx.fillStyle = '#222';
                ctx.fillRect(18, 58, 14, 6);
                ctx.fillRect(32, 58, 14, 6);
            });
        }

        function createEnemyDeadTexture() {
            return createTexture((ctx, s) => {
                ctx.fillStyle = '#443333';
                ctx.fillRect(8, 40, 48, 16);
                ctx.fillStyle = '#990000';
                ctx.fillRect(12, 42, 40, 10);
                ctx.fillStyle = '#dda87a';
                ctx.fillRect(48, 42, 12, 10);
            });
        }

        const enemyTex = createEnemyTexture();
        const enemyDeadTex = createEnemyDeadTexture();

        function spawnEnemy(x, z) {
            const spriteMat = new THREE.SpriteMaterial({ map: enemyTex });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.position.set(x, 0.9, z);
            sprite.scale.set(1.2, 1.6, 1);
            sprite.userData = {
                health: 3,
                alive: true,
                alertDistance: 10,
                shootCooldown: 0,
                type: 'enemy',
            };
            scene.add(sprite);
            state.enemies.push(sprite);
        }

        // ─── Pickups ───────────────────────────────────
        function spawnPickup(x, z, type) {
            let color;
            if (type === 'health') color = 0xff0000;
            else if (type === 'ammo') color = 0xffcc00;
            else color = 0x00ffcc;

            const geo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const mat = new THREE.MeshLambertMaterial({ color, emissive: color, emissiveIntensity: 0.3 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, 0.3, z);
            mesh.userData = { type, collected: false };
            scene.add(mesh);
            state.pickups.push(mesh);
        }

        // ─── Weapon (canvas-drawn) ─────────────────────
        const weaponCanvas = document.createElement('canvas');
        weaponCanvas.width = 200;
        weaponCanvas.height = 200;
        weaponCanvas.id = 'weapon';
        document.body.appendChild(weaponCanvas);
        const wCtx = weaponCanvas.getContext('2d');

        function drawWeapon(firing) {
            wCtx.clearRect(0, 0, 200, 200);

            if (firing) {
                // Muzzle flash
                wCtx.fillStyle = '#ffff00';
                wCtx.beginPath();
                wCtx.arc(100, 60, 25, 0, Math.PI * 2);
                wCtx.fill();
                wCtx.fillStyle = '#ff8800';
                wCtx.beginPath();
                wCtx.arc(100, 60, 15, 0, Math.PI * 2);
                wCtx.fill();
                wCtx.fillStyle = '#ffffff';
                wCtx.beginPath();
                wCtx.arc(100, 60, 6, 0, Math.PI * 2);
                wCtx.fill();
            }

            // Barrel
            wCtx.fillStyle = '#555';
            wCtx.fillRect(90, 70, 20, 80);
            wCtx.fillStyle = '#444';
            wCtx.fillRect(85, 80, 30, 70);

            // Magazine
            wCtx.fillStyle = '#333';
            wCtx.fillRect(80, 130, 40, 30);

            // Grip
            wCtx.fillStyle = '#654321';
            wCtx.fillRect(82, 150, 36, 50);

            // Hand
            wCtx.fillStyle = '#dda87a';
            wCtx.fillRect(70, 160, 25, 30);
            wCtx.fillRect(105, 160, 25, 30);
        }
        drawWeapon(false);

        // ─── Input ─────────────────────────────────────
        const keys = {};
        let pointerLocked = false;
        let yaw = 0, pitch = 0;

        document.addEventListener('keydown', e => { keys[e.code] = true; });
        document.addEventListener('keyup', e => { keys[e.code] = false; });

        document.addEventListener('click', () => {
            if (!pointerLocked) {
                renderer.domElement.requestPointerLock();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            pointerLocked = document.pointerLockElement === renderer.domElement;
            document.getElementById('instructions').style.display = pointerLocked ? 'none' : 'flex';
        });

        document.addEventListener('mousemove', e => {
            if (!pointerLocked) return;
            yaw -= e.movementX * state.mouseSensitivity;
            pitch -= e.movementY * state.mouseSensitivity;
            pitch = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, pitch));
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
        });

        document.addEventListener('mousedown', e => {
            if (pointerLocked && e.button === 0) {
                shoot();
            }
        });

        document.addEventListener('keydown', e => {
            if (e.code === 'KeyM') {
                state.minimapVisible = !state.minimapVisible;
                document.getElementById('minimap').style.display = state.minimapVisible ? 'block' : 'none';
            }
        });

        // ─── Collision ─────────────────────────────────
        function isBlocked(wx, wz) {
            const gx = Math.floor(wx / CELL);
            const gz = Math.floor(wz / CELL);
            const cell = getCell(gx, gz);
            if (cell >= 1 && cell <= 4) return true;
            if (cell === 5) {
                // Check if door is open
                const door = state.doors.find(d => d.userData.gridX === gx && d.userData.gridZ === gz);
                if (door && door.userData.openAmount > 0.8) return false;
                return true;
            }
            return false;
        }

        // ─── Shooting ──────────────────────────────────
        function shoot() {
            if (state.shootCooldown > 0 || state.ammo <= 0) return;
            state.ammo--;
            state.shootCooldown = 0.3;
            state.shooting = true;
            drawWeapon(true);
            setTimeout(() => { drawWeapon(false); state.shooting = false; }, 100);

            // Raycasting for hit detection
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            for (const enemy of state.enemies) {
                if (!enemy.userData.alive) continue;
                const dist = camera.position.distanceTo(enemy.position);
                if (dist > 15) continue;

                const dir = new THREE.Vector3().subVectors(enemy.position, camera.position).normalize();
                const camDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                const dot = dir.dot(camDir);

                // Wider hit zone for sprite enemies
                if (dot > 0.95) {
                    enemy.userData.health--;
                    if (enemy.userData.health <= 0) {
                        enemy.userData.alive = false;
                        enemy.material.map = enemyDeadTex;
                        enemy.material.needsUpdate = true;
                        enemy.position.y = 0.3;
                        enemy.scale.set(1.5, 0.5, 1);
                        state.score += 100;
                    }
                    break;
                }
            }
        }

        // ─── Door Interaction ──────────────────────────
        function tryOpenDoor() {
            const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const pos = camera.position;
            for (const door of state.doors) {
                const dist = pos.distanceTo(door.position);
                if (dist < 3 && !door.userData.open) {
                    door.userData.opening = true;
                }
            }
        }

        document.addEventListener('keydown', e => {
            if (e.code === 'KeyE') tryOpenDoor();
        });

        // ─── Minimap ───────────────────────────────────
        const minimapCanvas = document.getElementById('minimap');
        const mCtx = minimapCanvas.getContext('2d');
        const mmScale = 200 / MAP_W;

        function drawMinimap() {
            mCtx.fillStyle = '#000';
            mCtx.fillRect(0, 0, 200, 200);

            for (let z = 0; z < MAP_H; z++) {
                for (let x = 0; x < MAP_W; x++) {
                    const cell = getCell(x, z);
                    if (cell === 0 || cell >= 6) {
                        mCtx.fillStyle = '#222';
                    } else if (cell === 1) {
                        mCtx.fillStyle = '#666';
                    } else if (cell === 2) {
                        mCtx.fillStyle = '#843';
                    } else if (cell === 3) {
                        mCtx.fillStyle = '#338';
                    } else if (cell === 4) {
                        mCtx.fillStyle = '#654';
                    } else if (cell === 5) {
                        mCtx.fillStyle = '#999';
                    }
                    mCtx.fillRect(x * mmScale, z * mmScale, mmScale, mmScale);
                }
            }

            // Enemies
            for (const e of state.enemies) {
                if (!e.userData.alive) continue;
                mCtx.fillStyle = '#f00';
                const ex = (e.position.x / CELL) * mmScale;
                const ez = (e.position.z / CELL) * mmScale;
                mCtx.fillRect(ex - 2, ez - 2, 4, 4);
            }

            // Player
            const px = (camera.position.x / CELL) * mmScale;
            const pz = (camera.position.z / CELL) * mmScale;
            mCtx.fillStyle = '#0f0';
            mCtx.beginPath();
            mCtx.arc(px, pz, 3, 0, Math.PI * 2);
            mCtx.fill();

            // Direction
            const dx = Math.sin(yaw) * 8;
            const dz = -Math.cos(yaw) * 8;
            mCtx.strokeStyle = '#0f0';
            mCtx.lineWidth = 2;
            mCtx.beginPath();
            mCtx.moveTo(px, pz);
            mCtx.lineTo(px - dx, pz - dz);
            mCtx.stroke();
        }

        // ─── HUD Update ────────────────────────────────
        function updateHUD() {
            document.getElementById('hud-health').textContent = state.health + '%';
            document.getElementById('hud-ammo').textContent = state.ammo;
            document.getElementById('hud-score').textContent = state.score;
            document.getElementById('hud-level').textContent = state.level;
        }

        // ─── Enemy AI ──────────────────────────────────
        function updateEnemies(dt) {
            for (const enemy of state.enemies) {
                if (!enemy.userData.alive) continue;

                const dist = camera.position.distanceTo(enemy.position);
                if (dist < enemy.userData.alertDistance) {
                    // Face player (sprites auto-face camera)
                    // Move toward player slowly
                    if (dist > 2.5) {
                        const dir = new THREE.Vector3()
                            .subVectors(camera.position, enemy.position)
                            .normalize();
                        const newX = enemy.position.x + dir.x * 1.5 * dt;
                        const newZ = enemy.position.z + dir.z * 1.5 * dt;
                        if (!isBlocked(newX, newZ)) {
                            enemy.position.x = newX;
                            enemy.position.z = newZ;
                        }
                    }

                    // Shoot at player
                    enemy.userData.shootCooldown -= dt;
                    if (enemy.userData.shootCooldown <= 0 && dist < 12) {
                        enemy.userData.shootCooldown = 1.5 + Math.random();
                        // Hit chance based on distance
                        const hitChance = Math.max(0.1, 1 - dist / 15);
                        if (Math.random() < hitChance) {
                            const dmg = Math.floor(5 + Math.random() * 10);
                            state.health = Math.max(0, state.health - dmg);
                            // Damage flash
                            const overlay = document.getElementById('damage-overlay');
                            overlay.style.opacity = '0.6';
                            setTimeout(() => overlay.style.opacity = '0', 200);
                        }
                    }
                }
            }
        }

        // ─── Pickup Collection ─────────────────────────
        function checkPickups() {
            for (const pickup of state.pickups) {
                if (pickup.userData.collected) continue;
                const dist = camera.position.distanceTo(pickup.position);
                if (dist < 1.2) {
                    pickup.userData.collected = true;
                    scene.remove(pickup);
                    if (pickup.userData.type === 'health') {
                        state.health = Math.min(100, state.health + 25);
                    } else if (pickup.userData.type === 'ammo') {
                        state.ammo += 20;
                    } else if (pickup.userData.type === 'treasure') {
                        state.score += 500;
                    }
                }
            }
        }

        // ─── Game Loop ─────────────────────────────────
        const clock = new THREE.Clock();

        function gameLoop() {
            requestAnimationFrame(gameLoop);
            const dt = Math.min(clock.getDelta(), 0.1);

            if (!pointerLocked) {
                renderer.render(scene, camera);
                return;
            }

            // Movement
            const speed = state.moveSpeed * (keys['ShiftLeft'] || keys['ShiftRight'] ? state.runMultiplier : 1) * dt;
            const forward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
            const right = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw));

            let moveDir = new THREE.Vector3();
            if (keys['KeyW']) moveDir.add(forward);
            if (keys['KeyS']) moveDir.sub(forward);
            if (keys['KeyA']) moveDir.sub(right);
            if (keys['KeyD']) moveDir.add(right);

            if (moveDir.length() > 0) {
                moveDir.normalize().multiplyScalar(speed);
                // Collision with sliding
                const newX = camera.position.x + moveDir.x;
                const newZ = camera.position.z + moveDir.z;
                const r = 0.3; // collision radius

                if (!isBlocked(newX + r, camera.position.z) &&
                    !isBlocked(newX - r, camera.position.z) &&
                    !isBlocked(newX + r, camera.position.z + r) &&
                    !isBlocked(newX - r, camera.position.z - r) &&
                    !isBlocked(newX + r, camera.position.z - r) &&
                    !isBlocked(newX - r, camera.position.z + r)) {
                    camera.position.x = newX;
                }
                if (!isBlocked(camera.position.x, newZ + r) &&
                    !isBlocked(camera.position.x, newZ - r) &&
                    !isBlocked(camera.position.x + r, newZ + r) &&
                    !isBlocked(camera.position.x - r, newZ - r) &&
                    !isBlocked(camera.position.x + r, newZ - r) &&
                    !isBlocked(camera.position.x - r, newZ + r)) {
                    camera.position.z = newZ;
                }
            }

            // Head bob
            if (moveDir.length() > 0) {
                camera.position.y = 0.9 + Math.sin(clock.elapsedTime * 8) * 0.05;
                // Weapon bob
                weaponCanvas.style.transform = `translateX(${-50 + Math.sin(clock.elapsedTime * 8) * 3}%) translateY(${Math.abs(Math.sin(clock.elapsedTime * 8)) * 5}px)`;
            } else {
                camera.position.y = 0.9;
                weaponCanvas.style.transform = 'translateX(-50%)';
            }

            // Update player light
            playerLight.position.copy(camera.position);

            // Shoot cooldown
            if (state.shootCooldown > 0) state.shootCooldown -= dt;

            // Door animation
            for (const door of state.doors) {
                if (door.userData.opening && door.userData.openAmount < 1) {
                    door.userData.openAmount += dt * 2;
                    door.position.y = CELL / 2 + door.userData.openAmount * CELL;
                    if (door.userData.openAmount >= 1) {
                        door.userData.open = true;
                        door.userData.opening = false;
                    }
                }
            }

            // Pickup rotation
            for (const pickup of state.pickups) {
                if (!pickup.userData.collected) {
                    pickup.rotation.y += dt * 2;
                    pickup.position.y = 0.3 + Math.sin(clock.elapsedTime * 3) * 0.1;
                }
            }

            updateEnemies(dt);
            checkPickups();
            updateHUD();
            if (state.minimapVisible) drawMinimap();

            renderer.render(scene, camera);
        }

        // ─── Resize Handler ────────────────────────────
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / (window.innerHeight - 80);
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight - 80);
        });

        gameLoop();
    </script>
</body>
</html>
